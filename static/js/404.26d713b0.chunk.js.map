{"version":3,"file":"static/js/404.26d713b0.chunk.js","mappings":"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","sources":["components/Content/Games/candy-crush/scenes/BootScene.ts","components/Content/Games/candy-crush/scenes/MainScene.ts","components/Content/Games/candy-crush/game.tsx"],"sourcesContent":["import Phaser from 'phaser'\nimport { GAME_WIDTH, GAME_HEIGHT, CANDY_COLORS } from '../constants'\n\nexport class BootScene extends Phaser.Scene {\n\tconstructor() {\n\t\tsuper({ key: 'BootScene' })\n\t}\n\n\tpreload() {\n\t\t// Create loading bar\n\t\tconst progressBar = this.add.graphics()\n\t\tconst progressBox = this.add.graphics()\n\n\t\tprogressBox.fillStyle(0x222222, 0.8)\n\t\tprogressBox.fillRect(GAME_WIDTH / 2 - 160, GAME_HEIGHT / 2 - 25, 320, 50)\n\n\t\tconst loadingText = this.add.text(\n\t\t\tGAME_WIDTH / 2,\n\t\t\tGAME_HEIGHT / 2 - 50,\n\t\t\t'Cargando...',\n\t\t\t{\n\t\t\t\tfontFamily: '\"Luckiest Guy\", Arial, sans-serif',\n\t\t\t\tfontSize: '24px',\n\t\t\t\tcolor: '#ffffff',\n\t\t\t}\n\t\t)\n\t\tloadingText.setOrigin(0.5, 0.5)\n\t\tloadingText.setResolution(Math.min(window.devicePixelRatio || 1, 2))\n\n\t\t// Progress bar update\n\t\tthis.load.on('progress', (value: number) => {\n\t\t\tprogressBar.clear()\n\t\t\tprogressBar.fillStyle(CANDY_COLORS[3], 1) // Green\n\t\t\tprogressBar.fillRect(\n\t\t\t\tGAME_WIDTH / 2 - 150,\n\t\t\t\tGAME_HEIGHT / 2 - 15,\n\t\t\t\t300 * value,\n\t\t\t\t30\n\t\t\t)\n\t\t})\n\n\t\tthis.load.on('complete', () => {\n\t\t\tprogressBar.destroy()\n\t\t\tprogressBox.destroy()\n\t\t\tloadingText.destroy()\n\t\t})\n\n\t\t// Build image paths based on skin\n\t\tconst skin = this.registry.get('skin') as string | undefined\n\t\tconst basePath = '/games/candy-crush/sprites/'\n\t\tconst skinPath = skin ? `skins/${skin}/` : ''\n\n\t\t// Try to load candy spritesheet\n\t\t// Falls back to procedural graphics if not available\n\t\tthis.load.spritesheet('candies', `${basePath}${skinPath}candies.webp`, {\n\t\t\tframeWidth: 84,\n\t\t\tframeHeight: 84,\n\t\t})\n\n\t\t// Load particle spritesheet (9 frames, 128x128 each)\n\t\tthis.load.spritesheet('particles', `${basePath}${skinPath}particles.webp`, {\n\t\t\tframeWidth: 128,\n\t\t\tframeHeight: 128,\n\t\t})\n\t}\n\n\tcreate() {\n\t\t// Check if candies loaded, if not we'll use procedural graphics\n\t\tconst candiesLoaded = this.textures.exists('candies')\n\t\tthis.registry.set('useProcedural', !candiesLoaded)\n\n\t\t// Generate procedural candy textures if needed\n\t\tif (!candiesLoaded) {\n\t\t\tthis.generateProceduralCandies()\n\t\t}\n\n\t\t// Generate a simple particle texture if spritesheet not loaded\n\t\tif (!this.textures.exists('particles')) {\n\t\t\tthis.generateParticleTexture()\n\t\t}\n\n\t\t// Transition to main game scene\n\t\tthis.scene.start('MainScene')\n\t}\n\n\tprivate generateProceduralCandies() {\n\t\t// Generate candy textures using graphics\n\t\tconst graphics = this.make.graphics({ x: 0, y: 0 })\n\n\t\tfor (let i = 0; i < CANDY_COLORS.length; i++) {\n\t\t\tgraphics.clear()\n\n\t\t\t// Draw candy circle with gradient-like effect\n\t\t\tconst color = CANDY_COLORS[i]\n\n\t\t\t// Outer glow\n\t\t\tgraphics.fillStyle(color, 0.3)\n\t\t\tgraphics.fillCircle(32, 32, 30)\n\n\t\t\t// Main body\n\t\t\tgraphics.fillStyle(color, 1)\n\t\t\tgraphics.fillCircle(32, 32, 26)\n\n\t\t\t// Highlight\n\t\t\tgraphics.fillStyle(0xffffff, 0.4)\n\t\t\tgraphics.fillCircle(26, 26, 10)\n\n\t\t\t// Inner highlight\n\t\t\tgraphics.fillStyle(0xffffff, 0.6)\n\t\t\tgraphics.fillCircle(24, 24, 5)\n\n\t\t\t// Generate texture from graphics\n\t\t\tgraphics.generateTexture(`candy-${i}`, 64, 64)\n\t\t}\n\n\t\tgraphics.destroy()\n\t}\n\n\tprivate generateParticleTexture() {\n\t\tconst graphics = this.make.graphics({ x: 0, y: 0 })\n\n\t\t// Simple circular particle\n\t\tgraphics.fillStyle(0xffffff, 1)\n\t\tgraphics.fillCircle(8, 8, 6)\n\t\tgraphics.fillStyle(0xffffff, 0.5)\n\t\tgraphics.fillCircle(8, 8, 8)\n\n\t\tgraphics.generateTexture('particle', 16, 16)\n\t\tgraphics.destroy()\n\t}\n}\n","import Phaser from 'phaser'\nimport {\n\tGAME_WIDTH,\n\tGAME_HEIGHT,\n\tGRID,\n\tSCORING,\n\tANIMATION,\n\tCANDY_COLORS,\n\tCOLORS,\n\tUI,\n\tCANDY_SPRITE,\n\tGRID_PIXEL_SIZE,\n\tLEVELS,\n\tLevelConfig,\n\tBOMB_FRAMES,\n\tBOMB_SCORING,\n} from '../constants'\nimport { CandyData, Match, GameState, GamePhase, BombType } from '../types'\nimport { CandyCrushAudioManager } from '../utils/audioManager'\n\nexport class MainScene extends Phaser.Scene {\n\t// Grid data\n\tprivate grid: (CandyData | null)[][] = []\n\tprivate gridContainer!: Phaser.GameObjects.Container\n\n\t// Level configuration\n\tprivate levelConfig!: LevelConfig\n\tprivate candyTypes!: number\n\n\t// Game state\n\tprivate gameState!: GameState\n\tprivate selectedCandy: CandyData | null = null\n\tprivate isAnimating = false\n\tprivate useProcedural = false\n\n\t// UI elements\n\tprivate scoreText!: Phaser.GameObjects.Text\n\tprivate movesText!: Phaser.GameObjects.Text\n\tprivate targetText!: Phaser.GameObjects.Text\n\tprivate progressBar!: Phaser.GameObjects.Graphics\n\tprivate chainIndicator!: Phaser.GameObjects.Text\n\n\t// Callbacks from React\n\tprivate onScoreUpdate!: (score: number) => void\n\tprivate onMovesUpdate!: (moves: number) => void\n\tprivate onGameComplete!: (won: boolean, score: number) => void\n\tprivate onPhaseChange!: (phase: GamePhase) => void\n\n\t// Selection indicator\n\tprivate selectionIndicator!: Phaser.GameObjects.Graphics\n\n\t// Audio manager\n\tprivate audio!: CandyCrushAudioManager\n\n\tconstructor() {\n\t\tsuper({ key: 'MainScene' })\n\t}\n\n\tcreate() {\n\t\t// Get callbacks from registry\n\t\tthis.onScoreUpdate = this.registry.get('onScoreUpdate') || (() => {})\n\t\tthis.onMovesUpdate = this.registry.get('onMovesUpdate') || (() => {})\n\t\tthis.onGameComplete = this.registry.get('onGameComplete') || (() => {})\n\t\tthis.onPhaseChange = this.registry.get('onPhaseChange') || (() => {})\n\n\t\t// Check if using procedural graphics\n\t\tthis.useProcedural = this.registry.get('useProcedural') || false\n\n\t\t// Get audio manager from registry\n\t\tthis.audio = this.registry.get('audioManager')\n\n\t\t// Get level configuration from registry (default to level 1)\n\t\tthis.levelConfig = this.registry.get('levelConfig') || LEVELS[0]\n\t\tthis.candyTypes = this.levelConfig.candyTypes\n\n\t\t// Initialize game state with level-specific values\n\t\tthis.gameState = {\n\t\t\tphase: 'playing',\n\t\t\tscore: 0,\n\t\t\tmoves: this.levelConfig.moves,\n\t\t\ttargetScore: this.levelConfig.targetScore,\n\t\t\tlivesRemaining: this.registry.get('lives') || 3,\n\t\t\tchainLevel: 0,\n\t\t\tlastMatchPoints: 0,\n\t\t}\n\n\t\t// Setup game elements\n\t\tthis.createBackground()\n\t\tthis.createUI()\n\t\tthis.createGrid()\n\t\tthis.fillGridWithCandies()\n\t\tthis.removeInitialMatches()\n\t\tthis.setupInput()\n\n\t\t// Notify React of initial state\n\t\tthis.onMovesUpdate(this.gameState.moves)\n\t\tthis.onScoreUpdate(this.gameState.score)\n\t\tthis.onPhaseChange('playing')\n\t}\n\n\t// ==================== BACKGROUND & UI ====================\n\n\tprivate createBackground() {\n\t\t// Main background\n\t\tconst bg = this.add.graphics()\n\t\tbg.fillStyle(COLORS.background, 1)\n\t\tbg.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT)\n\n\t\t// Grid background with rounded corners effect\n\t\tconst gridBg = this.add.graphics()\n\t\tgridBg.fillStyle(COLORS.gridBackground, 1)\n\t\tgridBg.fillRoundedRect(\n\t\t\tGRID.offsetX - 10,\n\t\t\tGRID.offsetY - 10,\n\t\t\tGRID_PIXEL_SIZE + 20,\n\t\t\tGRID_PIXEL_SIZE + 20,\n\t\t\t15\n\t\t)\n\n\t\t// Grid border\n\t\tgridBg.lineStyle(3, COLORS.gridBorder, 1)\n\t\tgridBg.strokeRoundedRect(\n\t\t\tGRID.offsetX - 10,\n\t\t\tGRID.offsetY - 10,\n\t\t\tGRID_PIXEL_SIZE + 20,\n\t\t\tGRID_PIXEL_SIZE + 20,\n\t\t\t15\n\t\t)\n\t}\n\n\tprivate createUI() {\n\t\tconst gameFont = '\"Luckiest Guy\", Arial, sans-serif'\n\t\tconst textResolution = Math.min(window.devicePixelRatio || 1, 2)\n\n\t\t// Create header panel background\n\t\tthis.createHeaderPanel()\n\n\t\t// Target score display\n\t\tthis.targetText = this.add.text(\n\t\t\tUI.targetDisplay.x,\n\t\t\tUI.targetDisplay.y,\n\t\t\t'',\n\t\t\t{\n\t\t\t\tfontFamily: gameFont,\n\t\t\t\tfontSize: '24px',\n\t\t\t\tcolor: '#ffffff',\n\t\t\t\talign: 'center',\n\t\t\t}\n\t\t)\n\t\tthis.targetText.setOrigin(0.5, 0.5)\n\t\tthis.targetText.setResolution(textResolution)\n\t\tthis.updateTargetDisplay()\n\n\t\t// Score display\n\t\tthis.scoreText = this.add.text(UI.scoreDisplay.x, UI.scoreDisplay.y, '0', {\n\t\t\tfontFamily: gameFont,\n\t\t\tfontSize: '28px',\n\t\t\tcolor: '#ffd700',\n\t\t\talign: 'center',\n\t\t})\n\t\tthis.scoreText.setOrigin(0.5, 0.5)\n\t\tthis.scoreText.setResolution(textResolution)\n\n\t\t// Moves display\n\t\tthis.movesText = this.add.text(UI.movesDisplay.x, UI.movesDisplay.y, '', {\n\t\t\tfontFamily: gameFont,\n\t\t\tfontSize: '24px',\n\t\t\tcolor: '#ffffff',\n\t\t\talign: 'center',\n\t\t})\n\t\tthis.movesText.setOrigin(0.5, 0.5)\n\t\tthis.movesText.setResolution(textResolution)\n\t\tthis.updateMovesDisplay()\n\n\t\t// Progress bar background\n\t\tthis.progressBar = this.add.graphics()\n\t\tthis.updateProgressBar()\n\n\t\t// Chain indicator (hidden by default) - positioned below the grid\n\t\tconst gridBottom = GRID.offsetY + GRID_PIXEL_SIZE\n\t\tthis.chainIndicator = this.add.text(GAME_WIDTH / 2, gridBottom + 45, '', {\n\t\t\tfontFamily: gameFont,\n\t\t\tfontSize: '32px',\n\t\t\tcolor: '#ffffff',\n\t\t\talign: 'center',\n\t\t\tstroke: '#000000',\n\t\t\tstrokeThickness: 4,\n\t\t})\n\t\tthis.chainIndicator.setOrigin(0.5, 0.5)\n\t\tthis.chainIndicator.setResolution(textResolution)\n\t\tthis.chainIndicator.setAlpha(0)\n\n\t\t// Selection indicator\n\t\tthis.selectionIndicator = this.add.graphics()\n\t\tthis.selectionIndicator.setDepth(10)\n\t}\n\n\tprivate createHeaderPanel() {\n\t\tconst panel = this.add.graphics()\n\n\t\t// Main header panel background with gradient effect\n\t\tpanel.fillStyle(COLORS.headerPanel, 1)\n\t\tpanel.fillRoundedRect(\n\t\t\tUI.header.x,\n\t\t\tUI.header.y,\n\t\t\tUI.header.width,\n\t\t\tUI.header.height,\n\t\t\tUI.header.borderRadius\n\t\t)\n\n\t\t// Subtle inner highlight at top\n\t\tpanel.fillStyle(0xffffff, 0.05)\n\t\tpanel.fillRoundedRect(\n\t\t\tUI.header.x + 2,\n\t\t\tUI.header.y + 2,\n\t\t\tUI.header.width - 4,\n\t\t\t20,\n\t\t\t{\n\t\t\t\ttl: UI.header.borderRadius - 2,\n\t\t\t\ttr: UI.header.borderRadius - 2,\n\t\t\t\tbl: 0,\n\t\t\t\tbr: 0,\n\t\t\t}\n\t\t)\n\n\t\t// Header border\n\t\tpanel.lineStyle(2, COLORS.headerBorder, 1)\n\t\tpanel.strokeRoundedRect(\n\t\t\tUI.header.x,\n\t\t\tUI.header.y,\n\t\t\tUI.header.width,\n\t\t\tUI.header.height,\n\t\t\tUI.header.borderRadius\n\t\t)\n\n\t\t// Create stat cards\n\t\tconst cardY = UI.header.y + UI.header.padding\n\t\tconst cardHeight = UI.statCard.height\n\n\t\t// Target card (left)\n\t\tthis.createStatCard(\n\t\t\tpanel,\n\t\t\tUI.header.x + UI.header.padding,\n\t\t\tcardY,\n\t\t\tUI.statCard.width,\n\t\t\tcardHeight,\n\t\t\tCOLORS.targetAccent,\n\t\t\t'META'\n\t\t)\n\n\t\t// Score card (center) - wider\n\t\tconst scoreCardWidth = UI.statCard.width + 20\n\t\tthis.createStatCard(\n\t\t\tpanel,\n\t\t\tGAME_WIDTH / 2 - scoreCardWidth / 2,\n\t\t\tcardY,\n\t\t\tscoreCardWidth,\n\t\t\tcardHeight,\n\t\t\tCOLORS.scoreAccent,\n\t\t\t'PUNTOS'\n\t\t)\n\n\t\t// Moves card (right)\n\t\tthis.createStatCard(\n\t\t\tpanel,\n\t\t\tUI.header.x + UI.header.width - UI.header.padding - UI.statCard.width,\n\t\t\tcardY,\n\t\t\tUI.statCard.width,\n\t\t\tcardHeight,\n\t\t\tCOLORS.movesAccent,\n\t\t\t'TURNOS'\n\t\t)\n\t}\n\n\tprivate createStatCard(\n\t\tgraphics: Phaser.GameObjects.Graphics,\n\t\tx: number,\n\t\ty: number,\n\t\twidth: number,\n\t\theight: number,\n\t\taccentColor: number,\n\t\tlabel: string\n\t) {\n\t\tconst gameFont = '\"Luckiest Guy\", Arial, sans-serif'\n\t\tconst textResolution = Math.min(window.devicePixelRatio || 1, 2)\n\t\tconst accentHeight = UI.statCard.accentHeight\n\n\t\t// Card background\n\t\tgraphics.fillStyle(COLORS.statCardBg, 0.8)\n\t\tgraphics.fillRoundedRect(x, y, width, height, UI.statCard.borderRadius)\n\n\t\t// Accent bar at top (taller, contains label)\n\t\tgraphics.fillStyle(accentColor, 1)\n\t\tgraphics.fillRoundedRect(x, y, width, accentHeight, {\n\t\t\ttl: UI.statCard.borderRadius,\n\t\t\ttr: UI.statCard.borderRadius,\n\t\t\tbl: 0,\n\t\t\tbr: 0,\n\t\t})\n\n\t\t// Subtle border\n\t\tgraphics.lineStyle(1, accentColor, 0.3)\n\t\tgraphics.strokeRoundedRect(x, y, width, height, UI.statCard.borderRadius)\n\n\t\t// Label text inside accent bar (dark text for contrast)\n\t\tconst labelText = this.add.text(\n\t\t\tx + width / 2,\n\t\t\ty + accentHeight / 2,\n\t\t\tlabel,\n\t\t\t{\n\t\t\t\tfontFamily: gameFont,\n\t\t\t\tfontSize: '11px',\n\t\t\t\tcolor: '#1a1a2e',\n\t\t\t\talign: 'center',\n\t\t\t}\n\t\t)\n\t\tlabelText.setOrigin(0.5, 0.5)\n\t\tlabelText.setResolution(textResolution)\n\t}\n\n\tprivate updateTargetDisplay() {\n\t\tthis.targetText.setText(`${this.gameState.targetScore}`)\n\t}\n\n\tprivate updateMovesDisplay() {\n\t\tthis.movesText.setText(`${this.gameState.moves}`)\n\t}\n\n\tprivate updateProgressBar() {\n\t\tthis.progressBar.clear()\n\n\t\tconst barRadius = UI.progressBar.borderRadius\n\n\t\t// Background with subtle border\n\t\tthis.progressBar.fillStyle(0x0a0a15, 1)\n\t\tthis.progressBar.fillRoundedRect(\n\t\t\tUI.progressBar.x,\n\t\t\tUI.progressBar.y,\n\t\t\tUI.progressBar.width,\n\t\t\tUI.progressBar.height,\n\t\t\tbarRadius\n\t\t)\n\n\t\t// Progress fill\n\t\tconst progress = Math.min(\n\t\t\tthis.gameState.score / this.gameState.targetScore,\n\t\t\t1\n\t\t)\n\t\tif (progress > 0) {\n\t\t\tconst fillWidth = Math.max(UI.progressBar.width * progress, barRadius * 2)\n\t\t\tconst fillColor = progress >= 1 ? 0x4caf50 : COLORS.targetAccent\n\t\t\tthis.progressBar.fillStyle(fillColor, 1)\n\t\t\tthis.progressBar.fillRoundedRect(\n\t\t\t\tUI.progressBar.x,\n\t\t\t\tUI.progressBar.y,\n\t\t\t\tfillWidth,\n\t\t\t\tUI.progressBar.height,\n\t\t\t\tbarRadius\n\t\t\t)\n\n\t\t\t// Shine effect on progress\n\t\t\tthis.progressBar.fillStyle(0xffffff, 0.2)\n\t\t\tthis.progressBar.fillRoundedRect(\n\t\t\t\tUI.progressBar.x,\n\t\t\t\tUI.progressBar.y,\n\t\t\t\tfillWidth,\n\t\t\t\tUI.progressBar.height / 2,\n\t\t\t\t{ tl: barRadius, tr: barRadius, bl: 0, br: 0 }\n\t\t\t)\n\t\t}\n\n\t\t// Outer border\n\t\tthis.progressBar.lineStyle(1, COLORS.headerBorder, 0.5)\n\t\tthis.progressBar.strokeRoundedRect(\n\t\t\tUI.progressBar.x,\n\t\t\tUI.progressBar.y,\n\t\t\tUI.progressBar.width,\n\t\t\tUI.progressBar.height,\n\t\t\tbarRadius\n\t\t)\n\t}\n\n\t// ==================== GRID CREATION ====================\n\n\tprivate createGrid() {\n\t\tthis.gridContainer = this.add.container(GRID.offsetX, GRID.offsetY)\n\t\tthis.grid = []\n\n\t\tfor (let row = 0; row < GRID.size; row++) {\n\t\t\tthis.grid[row] = []\n\t\t\tfor (let col = 0; col < GRID.size; col++) {\n\t\t\t\tthis.grid[row][col] = null\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate fillGridWithCandies() {\n\t\tfor (let row = 0; row < GRID.size; row++) {\n\t\t\tfor (let col = 0; col < GRID.size; col++) {\n\t\t\t\tconst candy = this.createCandy(row, col)\n\t\t\t\tthis.grid[row][col] = candy\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate createCandy(\n\t\trow: number,\n\t\tcol: number,\n\t\ttype?: number,\n\t\tbombType?: BombType\n\t): CandyData {\n\t\t// Determine if this should be a bomb (random spawn during fill)\n\t\tconst bombConfig = this.levelConfig.bombConfig\n\t\tlet isBomb = false\n\t\tlet actualBombType: BombType | undefined = bombType\n\n\t\t// If bomb type is explicitly provided, use it\n\t\tif (actualBombType) {\n\t\t\tisBomb = true\n\t\t} else if (\n\t\t\tbombConfig &&\n\t\t\ttype === undefined &&\n\t\t\tMath.random() < bombConfig.spawnChance\n\t\t) {\n\t\t\t// Random bomb spawn when filling empty cells\n\t\t\tisBomb = true\n\t\t\tactualBombType = Math.random() < 0.5 ? 'cross' : 'radius'\n\t\t}\n\n\t\t// Determine candy type\n\t\tlet candyType: number\n\t\tif (isBomb && actualBombType) {\n\t\t\t// Bombs use their special frame and type -1 (so they don't match with each other)\n\t\t\tcandyType = -1\n\t\t} else {\n\t\t\tcandyType =\n\t\t\t\ttype !== undefined ? type : Phaser.Math.Between(0, this.candyTypes - 1)\n\t\t}\n\n\t\tconst x = col * (GRID.cellSize + GRID.gap) + GRID.cellSize / 2\n\t\tconst y = row * (GRID.cellSize + GRID.gap) + GRID.cellSize / 2\n\n\t\tlet sprite: Phaser.GameObjects.Sprite\n\n\t\tif (isBomb && actualBombType) {\n\t\t\t// Bombs always use spritesheet frames 7 or 8\n\t\t\tconst frame = BOMB_FRAMES[actualBombType]\n\t\t\tsprite = this.add.sprite(x, y, 'candies', frame)\n\t\t} else if (this.useProcedural) {\n\t\t\tsprite = this.add.sprite(x, y, `candy-${candyType}`)\n\t\t} else {\n\t\t\tsprite = this.add.sprite(x, y, 'candies', candyType)\n\t\t}\n\n\t\tsprite.setDisplaySize(CANDY_SPRITE.displaySize, CANDY_SPRITE.displaySize)\n\t\tsprite.setInteractive()\n\t\tthis.gridContainer.add(sprite)\n\n\t\tconst candy: CandyData = {\n\t\t\trow,\n\t\t\tcol,\n\t\t\ttype: candyType,\n\t\t\tsprite,\n\t\t\tisBomb,\n\t\t\tbombType: actualBombType,\n\t\t}\n\n\t\treturn candy\n\t}\n\n\tprivate removeInitialMatches() {\n\t\tlet iterations = 0\n\t\tconst maxIterations = 100\n\n\t\twhile (iterations < maxIterations) {\n\t\t\tconst matches = this.findAllMatches()\n\t\t\tif (matches.length === 0) break\n\n\t\t\t// Replace matched candies with different types\n\t\t\tfor (const match of matches) {\n\t\t\t\tfor (const cell of match.cells) {\n\t\t\t\t\tconst candy = this.grid[cell.row][cell.col]\n\t\t\t\t\tif (candy && !candy.isBomb) {\n\t\t\t\t\t\t// Don't replace bombs - find a type that won't create a match\n\t\t\t\t\t\tconst newType = this.findNonMatchingType(cell.row, cell.col)\n\t\t\t\t\t\tcandy.type = newType\n\n\t\t\t\t\t\t// Update sprite\n\t\t\t\t\t\tif (candy.sprite) {\n\t\t\t\t\t\t\tif (this.useProcedural) {\n\t\t\t\t\t\t\t\tcandy.sprite.setTexture(`candy-${newType}`)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcandy.sprite.setFrame(newType)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titerations++\n\t\t}\n\t}\n\n\tprivate findNonMatchingType(row: number, col: number): number {\n\t\tconst invalidTypes = new Set<number>()\n\n\t\t// Check horizontal neighbors\n\t\tif (col >= 2) {\n\t\t\tconst left1 = this.grid[row][col - 1]\n\t\t\tconst left2 = this.grid[row][col - 2]\n\t\t\tif (left1 && left2 && left1.type === left2.type) {\n\t\t\t\tinvalidTypes.add(left1.type)\n\t\t\t}\n\t\t}\n\n\t\t// Check vertical neighbors\n\t\tif (row >= 2) {\n\t\t\tconst up1 = this.grid[row - 1][col]\n\t\t\tconst up2 = this.grid[row - 2][col]\n\t\t\tif (up1 && up2 && up1.type === up2.type) {\n\t\t\t\tinvalidTypes.add(up1.type)\n\t\t\t}\n\t\t}\n\n\t\t// Find valid type\n\t\tconst validTypes = []\n\t\tfor (let t = 0; t < this.candyTypes; t++) {\n\t\t\tif (!invalidTypes.has(t)) {\n\t\t\t\tvalidTypes.push(t)\n\t\t\t}\n\t\t}\n\n\t\treturn validTypes.length > 0\n\t\t\t? validTypes[Phaser.Math.Between(0, validTypes.length - 1)]\n\t\t\t: Phaser.Math.Between(0, this.candyTypes - 1)\n\t}\n\n\t// ==================== INPUT HANDLING ====================\n\n\tprivate setupInput() {\n\t\tlet dragStartCandy: CandyData | null = null\n\n\t\tthis.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {\n\t\t\tif (this.isAnimating || this.gameState.phase !== 'playing') return\n\n\t\t\tconst cell = this.getCellFromPointer(pointer)\n\t\t\tif (cell) {\n\t\t\t\tconst candy = this.grid[cell.row][cell.col]\n\t\t\t\tif (candy) {\n\t\t\t\t\t// Clear previous selection before selecting new candy\n\t\t\t\t\tif (this.selectedCandy && this.selectedCandy !== candy) {\n\t\t\t\t\t\tthis.clearSelection()\n\t\t\t\t\t}\n\t\t\t\t\tdragStartCandy = candy\n\t\t\t\t\tthis.selectCandy(candy)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tthis.input.on('pointermove', (pointer: Phaser.Input.Pointer) => {\n\t\t\tif (!pointer.isDown || this.isAnimating || !dragStartCandy) return\n\t\t\tif (this.gameState.phase !== 'playing') return\n\n\t\t\tconst cell = this.getCellFromPointer(pointer)\n\t\t\tif (cell) {\n\t\t\t\tconst targetCandy = this.grid[cell.row][cell.col]\n\t\t\t\tif (targetCandy && targetCandy !== dragStartCandy) {\n\t\t\t\t\tif (this.isAdjacent(dragStartCandy, targetCandy)) {\n\t\t\t\t\t\tthis.clearSelection()\n\t\t\t\t\t\tthis.trySwap(dragStartCandy, targetCandy)\n\t\t\t\t\t\tdragStartCandy = null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tthis.input.on('pointerup', () => {\n\t\t\t// Clear selection when releasing without a valid swap\n\t\t\tif (dragStartCandy) {\n\t\t\t\tthis.clearSelection()\n\t\t\t}\n\t\t\tdragStartCandy = null\n\t\t})\n\t}\n\n\tprivate getCellFromPointer(\n\t\tpointer: Phaser.Input.Pointer\n\t): { row: number; col: number } | null {\n\t\tconst x = pointer.x - GRID.offsetX\n\t\tconst y = pointer.y - GRID.offsetY\n\n\t\tconst col = Math.floor(x / (GRID.cellSize + GRID.gap))\n\t\tconst row = Math.floor(y / (GRID.cellSize + GRID.gap))\n\n\t\tif (row >= 0 && row < GRID.size && col >= 0 && col < GRID.size) {\n\t\t\treturn { row, col }\n\t\t}\n\t\treturn null\n\t}\n\n\tprivate isAdjacent(candy1: CandyData, candy2: CandyData): boolean {\n\t\tconst dr = Math.abs(candy1.row - candy2.row)\n\t\tconst dc = Math.abs(candy1.col - candy2.col)\n\t\treturn (dr === 1 && dc === 0) || (dr === 0 && dc === 1)\n\t}\n\n\tprivate selectCandy(candy: CandyData) {\n\t\tthis.selectedCandy = candy\n\n\t\t// Play select sound\n\t\tthis.audio?.playSelect()\n\n\t\t// Draw selection indicator\n\t\tthis.selectionIndicator.clear()\n\t\tthis.selectionIndicator.lineStyle(3, 0xffffff, 1)\n\n\t\tconst x = GRID.offsetX + candy.col * (GRID.cellSize + GRID.gap)\n\t\tconst y = GRID.offsetY + candy.row * (GRID.cellSize + GRID.gap)\n\n\t\tthis.selectionIndicator.strokeRoundedRect(\n\t\t\tx,\n\t\t\ty,\n\t\t\tGRID.cellSize,\n\t\t\tGRID.cellSize,\n\t\t\t8\n\t\t)\n\n\t\t// Scale up selected candy (relative to base scale)\n\t\tif (candy.sprite) {\n\t\t\tthis.tweens.add({\n\t\t\t\ttargets: candy.sprite,\n\t\t\t\tscale: CANDY_SPRITE.baseScale * ANIMATION.selectScale,\n\t\t\t\tduration: ANIMATION.selectDuration,\n\t\t\t\tease: 'Back.easeOut',\n\t\t\t})\n\t\t}\n\t}\n\n\tprivate clearSelection() {\n\t\tif (this.selectedCandy?.sprite) {\n\t\t\tthis.tweens.add({\n\t\t\t\ttargets: this.selectedCandy.sprite,\n\t\t\t\tscale: CANDY_SPRITE.baseScale,\n\t\t\t\tduration: ANIMATION.selectDuration,\n\t\t\t\tease: 'Back.easeIn',\n\t\t\t})\n\t\t}\n\t\tthis.selectedCandy = null\n\t\tthis.selectionIndicator.clear()\n\t}\n\n\t// ==================== SWAP LOGIC ====================\n\n\tprivate async trySwap(candy1: CandyData, candy2: CandyData) {\n\t\tthis.isAnimating = true\n\t\tthis.gameState.phase = 'animating'\n\n\t\t// Animate swap\n\t\tawait this.animateSwap(candy1, candy2)\n\n\t\t// Swap in grid\n\t\tthis.swapInGrid(candy1, candy2)\n\n\t\t// Check for matches at both positions\n\t\tconst matches = this.findMatchesAtPositions([\n\t\t\t{ row: candy1.row, col: candy1.col },\n\t\t\t{ row: candy2.row, col: candy2.col },\n\t\t])\n\n\t\tif (matches.length > 0) {\n\t\t\t// Valid move - process matches\n\t\t\tthis.decrementMoves()\n\t\t\tawait this.processMatches(matches)\n\t\t\tthis.checkGameEnd()\n\t\t} else {\n\t\t\t// Invalid move - swap back\n\t\t\tthis.audio?.playInvalidMove()\n\t\t\tawait this.animateSwap(candy1, candy2)\n\t\t\tthis.swapInGrid(candy1, candy2)\n\t\t}\n\n\t\tthis.isAnimating = false\n\t\tif (this.gameState.phase === 'animating') {\n\t\t\tthis.gameState.phase = 'playing'\n\t\t}\n\t}\n\n\tprivate swapInGrid(candy1: CandyData, candy2: CandyData) {\n\t\t// Swap positions in grid array\n\t\tthis.grid[candy1.row][candy1.col] = candy2\n\t\tthis.grid[candy2.row][candy2.col] = candy1\n\n\t\t// Swap row/col properties\n\t\tconst tempRow = candy1.row\n\t\tconst tempCol = candy1.col\n\t\tcandy1.row = candy2.row\n\t\tcandy1.col = candy2.col\n\t\tcandy2.row = tempRow\n\t\tcandy2.col = tempCol\n\t}\n\n\tprivate async animateSwap(\n\t\tcandy1: CandyData,\n\t\tcandy2: CandyData\n\t): Promise<void> {\n\t\t// Play swap sound\n\t\tthis.audio?.playSwap()\n\n\t\treturn new Promise(resolve => {\n\t\t\tconst x1 = candy1.col * (GRID.cellSize + GRID.gap) + GRID.cellSize / 2\n\t\t\tconst y1 = candy1.row * (GRID.cellSize + GRID.gap) + GRID.cellSize / 2\n\t\t\tconst x2 = candy2.col * (GRID.cellSize + GRID.gap) + GRID.cellSize / 2\n\t\t\tconst y2 = candy2.row * (GRID.cellSize + GRID.gap) + GRID.cellSize / 2\n\n\t\t\tlet completed = 0\n\t\t\tconst checkComplete = () => {\n\t\t\t\tcompleted++\n\t\t\t\tif (completed === 2) resolve()\n\t\t\t}\n\n\t\t\tif (candy1.sprite) {\n\t\t\t\tthis.tweens.add({\n\t\t\t\t\ttargets: candy1.sprite,\n\t\t\t\t\tx: x2,\n\t\t\t\t\ty: y2,\n\t\t\t\t\tduration: ANIMATION.swapDuration,\n\t\t\t\t\tease: 'Quad.easeOut',\n\t\t\t\t\tonComplete: checkComplete,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tcheckComplete()\n\t\t\t}\n\n\t\t\tif (candy2.sprite) {\n\t\t\t\tthis.tweens.add({\n\t\t\t\t\ttargets: candy2.sprite,\n\t\t\t\t\tx: x1,\n\t\t\t\t\ty: y1,\n\t\t\t\t\tduration: ANIMATION.swapDuration,\n\t\t\t\t\tease: 'Quad.easeOut',\n\t\t\t\t\tonComplete: checkComplete,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tcheckComplete()\n\t\t\t}\n\t\t})\n\t}\n\n\t// ==================== MATCH DETECTION ====================\n\n\tprivate findAllMatches(): Match[] {\n\t\tconst matches: Match[] = []\n\n\t\t// Find horizontal matches\n\t\tfor (let row = 0; row < GRID.size; row++) {\n\t\t\tlet matchStart = 0\n\t\t\tlet matchLength = 1\n\n\t\t\tfor (let col = 1; col <= GRID.size; col++) {\n\t\t\t\tconst current = col < GRID.size ? this.grid[row][col] : null\n\t\t\t\tconst previous = this.grid[row][col - 1]\n\n\t\t\t\tif (current && previous && current.type === previous.type) {\n\t\t\t\t\tmatchLength++\n\t\t\t\t} else {\n\t\t\t\t\tif (matchLength >= 3 && previous) {\n\t\t\t\t\t\tconst cells = []\n\t\t\t\t\t\tfor (let c = matchStart; c < matchStart + matchLength; c++) {\n\t\t\t\t\t\t\tcells.push({ row, col: c })\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatches.push({\n\t\t\t\t\t\t\tcells,\n\t\t\t\t\t\t\ttype: 'horizontal',\n\t\t\t\t\t\t\tlength: matchLength,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tmatchStart = col\n\t\t\t\t\tmatchLength = 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Find vertical matches\n\t\tfor (let col = 0; col < GRID.size; col++) {\n\t\t\tlet matchStart = 0\n\t\t\tlet matchLength = 1\n\n\t\t\tfor (let row = 1; row <= GRID.size; row++) {\n\t\t\t\tconst current = row < GRID.size ? this.grid[row][col] : null\n\t\t\t\tconst previous = this.grid[row - 1][col]\n\n\t\t\t\tif (current && previous && current.type === previous.type) {\n\t\t\t\t\tmatchLength++\n\t\t\t\t} else {\n\t\t\t\t\tif (matchLength >= 3 && previous) {\n\t\t\t\t\t\tconst cells = []\n\t\t\t\t\t\tfor (let r = matchStart; r < matchStart + matchLength; r++) {\n\t\t\t\t\t\t\tcells.push({ row: r, col })\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatches.push({\n\t\t\t\t\t\t\tcells,\n\t\t\t\t\t\t\ttype: 'vertical',\n\t\t\t\t\t\t\tlength: matchLength,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\tmatchStart = row\n\t\t\t\t\tmatchLength = 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.mergeIntersectingMatches(matches)\n\t}\n\n\tprivate findMatchesAtPositions(\n\t\tpositions: { row: number; col: number }[]\n\t): Match[] {\n\t\tconst allMatches: Match[] = []\n\n\t\tfor (const pos of positions) {\n\t\t\tconst candy = this.grid[pos.row][pos.col]\n\t\t\tif (!candy) continue\n\n\t\t\t// Bombs (type -1) can join any match when swapped\n\t\t\t// Check for adjacent matches if this is a bomb\n\t\t\tif (candy.isBomb) {\n\t\t\t\t// Check horizontal neighbors for any match\n\t\t\t\tconst hMatch = this.findBombHorizontalMatch(pos.row, pos.col)\n\t\t\t\tif (hMatch.length >= 3) {\n\t\t\t\t\tconst cells = hMatch.map(c => ({ row: pos.row, col: c }))\n\t\t\t\t\tallMatches.push({\n\t\t\t\t\t\tcells,\n\t\t\t\t\t\ttype: 'horizontal',\n\t\t\t\t\t\tlength: hMatch.length,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\t// Check vertical neighbors for any match\n\t\t\t\tconst vMatch = this.findBombVerticalMatch(pos.row, pos.col)\n\t\t\t\tif (vMatch.length >= 3) {\n\t\t\t\t\tconst cells = vMatch.map(r => ({ row: r, col: pos.col }))\n\t\t\t\t\tallMatches.push({\n\t\t\t\t\t\tcells,\n\t\t\t\t\t\ttype: 'vertical',\n\t\t\t\t\t\tlength: vMatch.length,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Regular candy matching\n\t\t\t\t// Check horizontal\n\t\t\t\tconst hMatch = this.findHorizontalMatch(pos.row, pos.col, candy.type)\n\t\t\t\tif (hMatch.length >= 3) {\n\t\t\t\t\tconst cells = hMatch.map(c => ({ row: pos.row, col: c }))\n\t\t\t\t\tallMatches.push({\n\t\t\t\t\t\tcells,\n\t\t\t\t\t\ttype: 'horizontal',\n\t\t\t\t\t\tlength: hMatch.length,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\t// Check vertical\n\t\t\t\tconst vMatch = this.findVerticalMatch(pos.row, pos.col, candy.type)\n\t\t\t\tif (vMatch.length >= 3) {\n\t\t\t\t\tconst cells = vMatch.map(r => ({ row: r, col: pos.col }))\n\t\t\t\t\tallMatches.push({\n\t\t\t\t\t\tcells,\n\t\t\t\t\t\ttype: 'vertical',\n\t\t\t\t\t\tlength: vMatch.length,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.mergeIntersectingMatches(allMatches)\n\t}\n\n\t// Find horizontal match for a bomb - looks at neighbors to find what type to match\n\tprivate findBombHorizontalMatch(row: number, col: number): number[] {\n\t\t// Look for adjacent candy type to adopt\n\t\tlet targetType = -2 // Invalid\n\t\tif (\n\t\t\tcol > 0 &&\n\t\t\tthis.grid[row][col - 1] &&\n\t\t\t!this.grid[row][col - 1]!.isBomb\n\t\t) {\n\t\t\ttargetType = this.grid[row][col - 1]!.type\n\t\t} else if (\n\t\t\tcol < GRID.size - 1 &&\n\t\t\tthis.grid[row][col + 1] &&\n\t\t\t!this.grid[row][col + 1]!.isBomb\n\t\t) {\n\t\t\ttargetType = this.grid[row][col + 1]!.type\n\t\t}\n\n\t\tif (targetType < 0) return [col] // No valid neighbor\n\n\t\tconst result = [col]\n\n\t\t// Extend left\n\t\tlet c = col - 1\n\t\twhile (c >= 0) {\n\t\t\tconst neighbor = this.grid[row][c]\n\t\t\tif (neighbor && (neighbor.type === targetType || neighbor.isBomb)) {\n\t\t\t\tresult.unshift(c)\n\t\t\t\tc--\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Extend right\n\t\tc = col + 1\n\t\twhile (c < GRID.size) {\n\t\t\tconst neighbor = this.grid[row][c]\n\t\t\tif (neighbor && (neighbor.type === targetType || neighbor.isBomb)) {\n\t\t\t\tresult.push(c)\n\t\t\t\tc++\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn result\n\t}\n\n\t// Find vertical match for a bomb - looks at neighbors to find what type to match\n\tprivate findBombVerticalMatch(row: number, col: number): number[] {\n\t\t// Look for adjacent candy type to adopt\n\t\tlet targetType = -2 // Invalid\n\t\tif (\n\t\t\trow > 0 &&\n\t\t\tthis.grid[row - 1][col] &&\n\t\t\t!this.grid[row - 1][col]!.isBomb\n\t\t) {\n\t\t\ttargetType = this.grid[row - 1][col]!.type\n\t\t} else if (\n\t\t\trow < GRID.size - 1 &&\n\t\t\tthis.grid[row + 1][col] &&\n\t\t\t!this.grid[row + 1][col]!.isBomb\n\t\t) {\n\t\t\ttargetType = this.grid[row + 1][col]!.type\n\t\t}\n\n\t\tif (targetType < 0) return [row] // No valid neighbor\n\n\t\tconst result = [row]\n\n\t\t// Extend up\n\t\tlet r = row - 1\n\t\twhile (r >= 0) {\n\t\t\tconst neighbor = this.grid[r][col]\n\t\t\tif (neighbor && (neighbor.type === targetType || neighbor.isBomb)) {\n\t\t\t\tresult.unshift(r)\n\t\t\t\tr--\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// Extend down\n\t\tr = row + 1\n\t\twhile (r < GRID.size) {\n\t\t\tconst neighbor = this.grid[r][col]\n\t\t\tif (neighbor && (neighbor.type === targetType || neighbor.isBomb)) {\n\t\t\t\tresult.push(r)\n\t\t\t\tr++\n\t\t\t} else {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn result\n\t}\n\n\tprivate findHorizontalMatch(\n\t\trow: number,\n\t\tcol: number,\n\t\ttype: number\n\t): number[] {\n\t\tconst result = [col]\n\n\t\t// Extend left\n\t\tlet c = col - 1\n\t\twhile (c >= 0 && this.grid[row][c]?.type === type) {\n\t\t\tresult.unshift(c)\n\t\t\tc--\n\t\t}\n\n\t\t// Extend right\n\t\tc = col + 1\n\t\twhile (c < GRID.size && this.grid[row][c]?.type === type) {\n\t\t\tresult.push(c)\n\t\t\tc++\n\t\t}\n\n\t\treturn result\n\t}\n\n\tprivate findVerticalMatch(row: number, col: number, type: number): number[] {\n\t\tconst result = [row]\n\n\t\t// Extend up\n\t\tlet r = row - 1\n\t\twhile (r >= 0 && this.grid[r][col]?.type === type) {\n\t\t\tresult.unshift(r)\n\t\t\tr--\n\t\t}\n\n\t\t// Extend down\n\t\tr = row + 1\n\t\twhile (r < GRID.size && this.grid[r][col]?.type === type) {\n\t\t\tresult.push(r)\n\t\t\tr++\n\t\t}\n\n\t\treturn result\n\t}\n\n\tprivate mergeIntersectingMatches(matches: Match[]): Match[] {\n\t\tif (matches.length <= 1) return matches\n\n\t\tconst result: Match[] = []\n\t\tconst usedIndices = new Set<number>()\n\n\t\t// Find intersecting horizontal and vertical matches to create L/T shapes\n\t\tfor (let i = 0; i < matches.length; i++) {\n\t\t\tif (usedIndices.has(i)) continue\n\n\t\t\tconst match1 = matches[i]\n\t\t\tlet merged = false\n\n\t\t\tfor (let j = i + 1; j < matches.length; j++) {\n\t\t\t\tif (usedIndices.has(j)) continue\n\n\t\t\t\tconst match2 = matches[j]\n\n\t\t\t\t// Check if one is horizontal and other is vertical\n\t\t\t\tif (\n\t\t\t\t\t(match1.type === 'horizontal' && match2.type === 'vertical') ||\n\t\t\t\t\t(match1.type === 'vertical' && match2.type === 'horizontal')\n\t\t\t\t) {\n\t\t\t\t\t// Find intersection point\n\t\t\t\t\tconst intersection = this.findIntersection(match1, match2)\n\t\t\t\t\tif (intersection) {\n\t\t\t\t\t\t// Merge into L or T shape\n\t\t\t\t\t\tconst mergedCells = new Map<string, { row: number; col: number }>()\n\t\t\t\t\t\tfor (const cell of match1.cells) {\n\t\t\t\t\t\t\tmergedCells.set(`${cell.row},${cell.col}`, cell)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const cell of match2.cells) {\n\t\t\t\t\t\t\tmergedCells.set(`${cell.row},${cell.col}`, cell)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst cells = Array.from(mergedCells.values())\n\t\t\t\t\t\tconst isT =\n\t\t\t\t\t\t\tmatch1.length >= 3 &&\n\t\t\t\t\t\t\tmatch2.length >= 3 &&\n\t\t\t\t\t\t\t(match1.length > 3 || match2.length > 3)\n\n\t\t\t\t\t\tresult.push({\n\t\t\t\t\t\t\tcells,\n\t\t\t\t\t\t\ttype: isT ? 't-shape' : 'l-shape',\n\t\t\t\t\t\t\tlength: cells.length,\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tusedIndices.add(i)\n\t\t\t\t\t\tusedIndices.add(j)\n\t\t\t\t\t\tmerged = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!merged) {\n\t\t\t\tresult.push(match1)\n\t\t\t\tusedIndices.add(i)\n\t\t\t}\n\t\t}\n\n\t\treturn result\n\t}\n\n\tprivate findIntersection(\n\t\tmatch1: Match,\n\t\tmatch2: Match\n\t): { row: number; col: number } | null {\n\t\tfor (const cell1 of match1.cells) {\n\t\t\tfor (const cell2 of match2.cells) {\n\t\t\t\tif (cell1.row === cell2.row && cell1.col === cell2.col) {\n\t\t\t\t\treturn cell1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null\n\t}\n\n\tprivate matchesOverlap(match1: Match, match2: Match): boolean {\n\t\tfor (const cell1 of match1.cells) {\n\t\t\tfor (const cell2 of match2.cells) {\n\t\t\t\tif (cell1.row === cell2.row && cell1.col === cell2.col) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\t// ==================== BOMB ACTIVATION ====================\n\n\t// Get all cells cleared by a cross bomb (entire row + column)\n\tprivate getCrossBombCells(bomb: CandyData): { row: number; col: number }[] {\n\t\tconst cells: { row: number; col: number }[] = []\n\t\tconst addedCells = new Set<string>()\n\n\t\t// Add entire row\n\t\tfor (let c = 0; c < GRID.size; c++) {\n\t\t\tconst key = `${bomb.row},${c}`\n\t\t\tif (!addedCells.has(key)) {\n\t\t\t\tcells.push({ row: bomb.row, col: c })\n\t\t\t\taddedCells.add(key)\n\t\t\t}\n\t\t}\n\n\t\t// Add entire column\n\t\tfor (let r = 0; r < GRID.size; r++) {\n\t\t\tconst key = `${r},${bomb.col}`\n\t\t\tif (!addedCells.has(key)) {\n\t\t\t\tcells.push({ row: r, col: bomb.col })\n\t\t\t\taddedCells.add(key)\n\t\t\t}\n\t\t}\n\n\t\treturn cells\n\t}\n\n\t// Get all cells cleared by a radius bomb (3x3 area)\n\tprivate getRadiusBombCells(bomb: CandyData): { row: number; col: number }[] {\n\t\tconst cells: { row: number; col: number }[] = []\n\n\t\tfor (let dr = -1; dr <= 1; dr++) {\n\t\t\tfor (let dc = -1; dc <= 1; dc++) {\n\t\t\t\tconst r = bomb.row + dr\n\t\t\t\tconst c = bomb.col + dc\n\n\t\t\t\t// Check bounds\n\t\t\t\tif (r >= 0 && r < GRID.size && c >= 0 && c < GRID.size) {\n\t\t\t\t\tcells.push({ row: r, col: c })\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn cells\n\t}\n\n\t// Show bomb explosion visual effect\n\tprivate showBombExplosion(bomb: CandyData) {\n\t\t// Play bomb explosion sound\n\t\tthis.audio?.playBombExplode(bomb.bombType)\n\n\t\tif (!bomb.sprite) return\n\n\t\tconst x = bomb.sprite.x + GRID.offsetX\n\t\tconst y = bomb.sprite.y + GRID.offsetY\n\n\t\t// Create explosion ring\n\t\tconst explosion = this.add.graphics()\n\t\texplosion.setPosition(x, y)\n\n\t\t// Inner flash\n\t\texplosion.fillStyle(0xffffff, 0.8)\n\t\texplosion.fillCircle(0, 0, 20)\n\n\t\t// Animate expansion and fade\n\t\tthis.tweens.add({\n\t\t\ttargets: explosion,\n\t\t\tscale: bomb.bombType === 'cross' ? 4 : 2.5,\n\t\t\talpha: 0,\n\t\t\tduration: 400,\n\t\t\tease: 'Quad.easeOut',\n\t\t\tonComplete: () => explosion.destroy(),\n\t\t})\n\n\t\t// Create extra particles for bombs\n\t\tconst particleCount = bomb.bombType === 'cross' ? 16 : 12\n\t\tfor (let i = 0; i < particleCount; i++) {\n\t\t\tconst angle = (i / particleCount) * Math.PI * 2\n\t\t\tconst distance = bomb.bombType === 'cross' ? 80 : 50\n\n\t\t\tconst particle = this.add.graphics()\n\t\t\tparticle.fillStyle(0xffd700, 1)\n\t\t\tparticle.fillCircle(0, 0, 6)\n\t\t\tparticle.setPosition(x, y)\n\n\t\t\tthis.tweens.add({\n\t\t\t\ttargets: particle,\n\t\t\t\tx: x + Math.cos(angle) * distance,\n\t\t\t\ty: y + Math.sin(angle) * distance,\n\t\t\t\talpha: 0,\n\t\t\t\tscale: 0,\n\t\t\t\tduration: 500,\n\t\t\t\tease: 'Quad.easeOut',\n\t\t\t\tonComplete: () => particle.destroy(),\n\t\t\t})\n\t\t}\n\t}\n\n\t// Calculate bomb activation score\n\tprivate calculateBombScore(bomb: CandyData, cellsCleared: number): number {\n\t\tconst baseScore =\n\t\t\tbomb.bombType === 'cross'\n\t\t\t\t? BOMB_SCORING.crossActivation\n\t\t\t\t: BOMB_SCORING.radiusActivation\n\t\treturn baseScore + cellsCleared * BOMB_SCORING.perCandyCleared\n\t}\n\n\t// ==================== MATCH PROCESSING ====================\n\n\tprivate async processMatches(matches: Match[]) {\n\t\tlet chainLevel = 1\n\n\t\twhile (matches.length > 0) {\n\t\t\t// Show chain indicator\n\t\t\tif (chainLevel > 1) {\n\t\t\t\tthis.showChainIndicator(chainLevel)\n\t\t\t}\n\n\t\t\t// Find bombs in the matches\n\t\t\tconst bombsInMatches: CandyData[] = []\n\t\t\tfor (const match of matches) {\n\t\t\t\tfor (const cell of match.cells) {\n\t\t\t\t\tconst candy = this.grid[cell.row][cell.col]\n\t\t\t\t\tif (candy?.isBomb) {\n\t\t\t\t\t\tbombsInMatches.push(candy)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Collect all cells to clear (from matches + bomb activations)\n\t\t\tconst cellsToClear = new Map<string, { row: number; col: number }>()\n\n\t\t\t// Add match cells\n\t\t\tfor (const match of matches) {\n\t\t\t\tfor (const cell of match.cells) {\n\t\t\t\t\tcellsToClear.set(`${cell.row},${cell.col}`, cell)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Process bomb activations and chain reactions\n\t\t\tconst processedBombs = new Set<string>()\n\t\t\tconst bombQueue = [...bombsInMatches]\n\t\t\tlet totalBombScore = 0\n\n\t\t\twhile (bombQueue.length > 0) {\n\t\t\t\tconst bomb = bombQueue.shift()!\n\t\t\t\tconst bombKey = `${bomb.row},${bomb.col}`\n\n\t\t\t\tif (processedBombs.has(bombKey)) continue\n\t\t\t\tprocessedBombs.add(bombKey)\n\n\t\t\t\t// Show explosion effect\n\t\t\t\tthis.showBombExplosion(bomb)\n\n\t\t\t\t// Get cells cleared by this bomb\n\t\t\t\tconst bombCells =\n\t\t\t\t\tbomb.bombType === 'cross'\n\t\t\t\t\t\t? this.getCrossBombCells(bomb)\n\t\t\t\t\t\t: this.getRadiusBombCells(bomb)\n\n\t\t\t\t// Check for chain reactions (bombs cleared by other bombs)\n\t\t\t\tfor (const cell of bombCells) {\n\t\t\t\t\tconst key = `${cell.row},${cell.col}`\n\t\t\t\t\tif (!cellsToClear.has(key)) {\n\t\t\t\t\t\tcellsToClear.set(key, cell)\n\n\t\t\t\t\t\t// Check if this cell contains a bomb (chain reaction)\n\t\t\t\t\t\tconst clearedCandy = this.grid[cell.row][cell.col]\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tclearedCandy?.isBomb &&\n\t\t\t\t\t\t\t!processedBombs.has(`${clearedCandy.row},${clearedCandy.col}`)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tbombQueue.push(clearedCandy)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Calculate bomb score\n\t\t\t\ttotalBombScore += this.calculateBombScore(bomb, bombCells.length)\n\t\t\t}\n\n\t\t\t// Calculate points (regular matches + bomb bonus)\n\t\t\tconst matchPoints = this.calculateMatchPoints(matches, chainLevel)\n\t\t\tthis.addScore(matchPoints + totalBombScore)\n\n\t\t\t// Play match sound based on the largest match length\n\t\t\tconst maxMatchLength = Math.max(...matches.map(m => m.length))\n\t\t\tthis.audio?.playMatchSound(maxMatchLength)\n\n\t\t\t// Create matches array from cells to clear for animation\n\t\t\tconst cellsArray = Array.from(cellsToClear.values())\n\t\t\tconst clearMatch: Match = {\n\t\t\t\tcells: cellsArray,\n\t\t\t\ttype: 'horizontal', // Type doesn't matter for clearing\n\t\t\t\tlength: cellsArray.length,\n\t\t\t}\n\n\t\t\t// Check for 4+ matches to potentially spawn bombs as rewards\n\t\t\tconst bombReward = this.checkForBombReward(matches)\n\n\t\t\t// Animate and remove all cells\n\t\t\tawait this.animateMatches([clearMatch])\n\t\t\tthis.removeMatches([clearMatch])\n\n\t\t\t// Drop candies\n\t\t\tawait this.dropCandies()\n\n\t\t\t// Fill empty cells (potentially with bomb reward)\n\t\t\tawait this.fillEmptyCells(bombReward)\n\n\t\t\t// Check for new matches (cascade)\n\t\t\tmatches = this.findAllMatches()\n\t\t\tchainLevel++\n\t\t}\n\n\t\tthis.gameState.chainLevel = chainLevel - 1\n\n\t\t// Check if board needs shuffling (no valid moves available)\n\t\tawait this.checkAndShuffleIfNeeded()\n\t}\n\n\t// Check if matches should reward a bomb\n\tprivate checkForBombReward(\n\t\tmatches: Match[]\n\t): { row: number; col: number; bombType: BombType } | null {\n\t\tconst bombConfig = this.levelConfig.bombConfig\n\t\tif (!bombConfig) return null\n\n\t\t// Check for 4+ length matches\n\t\tfor (const match of matches) {\n\t\t\tif (match.length >= 4 && Math.random() < bombConfig.matchSpawnChance) {\n\t\t\t\t// 5+ match gets cross bomb, 4 match gets radius bomb\n\t\t\t\tconst bombType: BombType = match.length >= 5 ? 'cross' : 'radius'\n\t\t\t\t// Spawn at the center of the match\n\t\t\t\tconst centerIndex = Math.floor(match.cells.length / 2)\n\t\t\t\tconst cell = match.cells[centerIndex]\n\t\t\t\treturn { row: cell.row, col: cell.col, bombType }\n\t\t\t}\n\t\t}\n\n\t\treturn null\n\t}\n\n\tprivate calculateMatchPoints(matches: Match[], chainLevel: number): number {\n\t\tlet points = 0\n\n\t\tfor (const match of matches) {\n\t\t\tif (match.length === 3) {\n\t\t\t\tpoints += SCORING.match3\n\t\t\t} else if (match.length === 4) {\n\t\t\t\tpoints += SCORING.match4\n\t\t\t} else if (match.length >= 5) {\n\t\t\t\tpoints += SCORING.match5\n\t\t\t}\n\n\t\t\t// L/T shape bonus\n\t\t\tif (match.type === 'l-shape' || match.type === 't-shape') {\n\t\t\t\tpoints += SCORING.matchLT - SCORING.match3\n\t\t\t}\n\t\t}\n\n\t\t// Chain bonus\n\t\tif (chainLevel > 1) {\n\t\t\tpoints += SCORING.chainBonus * (chainLevel - 1)\n\t\t}\n\n\t\treturn points\n\t}\n\n\tprivate async animateMatches(matches: Match[]): Promise<void> {\n\t\tconst animations: Promise<void>[] = []\n\n\t\tconst processedCells = new Set<string>()\n\n\t\tfor (const match of matches) {\n\t\t\tfor (const cell of match.cells) {\n\t\t\t\tconst key = `${cell.row},${cell.col}`\n\t\t\t\tif (processedCells.has(key)) continue\n\t\t\t\tprocessedCells.add(key)\n\n\t\t\t\tconst candy = this.grid[cell.row][cell.col]\n\t\t\t\tif (candy) {\n\t\t\t\t\tanimations.push(this.animateClearCandy(candy))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tawait Promise.all(animations)\n\t}\n\n\tprivate async animateClearCandy(candy: CandyData): Promise<void> {\n\t\treturn new Promise(resolve => {\n\t\t\tif (!candy.sprite) {\n\t\t\t\tresolve()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Create particles\n\t\t\tthis.createMatchParticles(candy)\n\n\t\t\t// Scale down and fade sprite\n\t\t\tthis.tweens.add({\n\t\t\t\ttargets: candy.sprite,\n\t\t\t\tscale: 0,\n\t\t\t\talpha: 0,\n\t\t\t\tduration: ANIMATION.clearDuration,\n\t\t\t\tease: 'Back.easeIn',\n\t\t\t\tonComplete: () => resolve(),\n\t\t\t})\n\t\t})\n\t}\n\n\tprivate createMatchParticles(candy: CandyData) {\n\t\tif (!candy.sprite) return\n\n\t\tconst color = CANDY_COLORS[candy.type]\n\t\tconst useSprites = this.textures.exists('particles')\n\n\t\t// Create particles\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tconst x = candy.sprite.x + GRID.offsetX\n\t\t\tconst y = candy.sprite.y + GRID.offsetY\n\t\t\tconst angle = (i / 6) * Math.PI * 2\n\t\t\tconst distance = 30 + Math.random() * 20\n\n\t\t\tif (useSprites) {\n\t\t\t\t// Use particle spritesheet with random frame (0-8)\n\t\t\t\tconst frame = Phaser.Math.Between(0, 8)\n\t\t\t\tconst particle = this.add.sprite(x, y, 'particles', frame)\n\t\t\t\tparticle.setTint(color)\n\t\t\t\tparticle.setScale(0.4)\n\n\t\t\t\tthis.tweens.add({\n\t\t\t\t\ttargets: particle,\n\t\t\t\t\tx: x + Math.cos(angle) * distance,\n\t\t\t\t\ty: y + Math.sin(angle) * distance,\n\t\t\t\t\talpha: 0,\n\t\t\t\t\tscale: 0,\n\t\t\t\t\tduration: 400,\n\t\t\t\t\tease: 'Quad.easeOut',\n\t\t\t\t\tonComplete: () => particle.destroy(),\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t// Fallback to graphics\n\t\t\t\tconst particle = this.add.graphics()\n\t\t\t\tparticle.fillStyle(color, 1)\n\t\t\t\tparticle.fillCircle(0, 0, 4)\n\t\t\t\tparticle.x = x\n\t\t\t\tparticle.y = y\n\n\t\t\t\tthis.tweens.add({\n\t\t\t\t\ttargets: particle,\n\t\t\t\t\tx: x + Math.cos(angle) * distance,\n\t\t\t\t\ty: y + Math.sin(angle) * distance,\n\t\t\t\t\talpha: 0,\n\t\t\t\t\tscale: 0,\n\t\t\t\t\tduration: 400,\n\t\t\t\t\tease: 'Quad.easeOut',\n\t\t\t\t\tonComplete: () => particle.destroy(),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate removeMatches(matches: Match[]) {\n\t\tconst processedCells = new Set<string>()\n\n\t\tfor (const match of matches) {\n\t\t\tfor (const cell of match.cells) {\n\t\t\t\tconst key = `${cell.row},${cell.col}`\n\t\t\t\tif (processedCells.has(key)) continue\n\t\t\t\tprocessedCells.add(key)\n\n\t\t\t\tconst candy = this.grid[cell.row][cell.col]\n\t\t\t\tif (candy) {\n\t\t\t\t\tthis.destroyCandy(candy)\n\t\t\t\t\tthis.grid[cell.row][cell.col] = null\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate destroyCandy(candy: CandyData) {\n\t\tif (candy.sprite) {\n\t\t\tcandy.sprite.destroy()\n\t\t\tcandy.sprite = null\n\t\t}\n\t}\n\n\t// ==================== CASCADE ====================\n\n\tprivate async dropCandies(): Promise<void> {\n\t\tconst animations: Promise<void>[] = []\n\n\t\tfor (let col = 0; col < GRID.size; col++) {\n\t\t\tlet emptyRow = GRID.size - 1\n\n\t\t\tfor (let row = GRID.size - 1; row >= 0; row--) {\n\t\t\t\tconst candy = this.grid[row][col]\n\t\t\t\tif (candy) {\n\t\t\t\t\tif (row !== emptyRow) {\n\t\t\t\t\t\t// Move candy down\n\t\t\t\t\t\tthis.grid[emptyRow][col] = candy\n\t\t\t\t\t\tthis.grid[row][col] = null\n\t\t\t\t\t\tcandy.row = emptyRow\n\n\t\t\t\t\t\tconst dropDistance = emptyRow - row\n\t\t\t\t\t\tanimations.push(this.animateDrop(candy, dropDistance))\n\t\t\t\t\t}\n\t\t\t\t\temptyRow--\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tawait Promise.all(animations)\n\t}\n\n\tprivate async animateDrop(candy: CandyData, distance: number): Promise<void> {\n\t\treturn new Promise(resolve => {\n\t\t\tif (!candy.sprite) {\n\t\t\t\tresolve()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst targetY = candy.row * (GRID.cellSize + GRID.gap) + GRID.cellSize / 2\n\n\t\t\tthis.tweens.add({\n\t\t\t\ttargets: candy.sprite,\n\t\t\t\ty: targetY,\n\t\t\t\tduration: ANIMATION.dropDurationPerRow * distance,\n\t\t\t\tease: 'Bounce.easeOut',\n\t\t\t\tonComplete: () => resolve(),\n\t\t\t})\n\t\t})\n\t}\n\n\tprivate async fillEmptyCells(\n\t\tbombReward?: { row: number; col: number; bombType: BombType } | null\n\t): Promise<void> {\n\t\tconst animations: Promise<void>[] = []\n\n\t\tfor (let col = 0; col < GRID.size; col++) {\n\t\t\t// Count empty cells in this column (from top)\n\t\t\tconst emptyCells: number[] = []\n\t\t\tfor (let row = 0; row < GRID.size; row++) {\n\t\t\t\tif (!this.grid[row][col]) {\n\t\t\t\t\temptyCells.push(row)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fill from bottom to top (so lower positions get filled first)\n\t\t\tfor (let i = emptyCells.length - 1; i >= 0; i--) {\n\t\t\t\tconst row = emptyCells[i]\n\t\t\t\tconst fallIndex = emptyCells.length - i // 1 for bottom-most, increasing upward\n\n\t\t\t\t// Check if this is the bomb reward position\n\t\t\t\tlet candy: CandyData\n\t\t\t\tif (bombReward && bombReward.row === row && bombReward.col === col) {\n\t\t\t\t\tcandy = this.createCandy(row, col, undefined, bombReward.bombType)\n\t\t\t\t} else {\n\t\t\t\t\tcandy = this.createCandy(row, col)\n\t\t\t\t}\n\n\t\t\t\tthis.grid[row][col] = candy\n\n\t\t\t\t// Start above the grid - higher for candies filling higher rows\n\t\t\t\tif (candy.sprite) {\n\t\t\t\t\tconst startY = -GRID.cellSize * fallIndex - GRID.cellSize / 2\n\t\t\t\t\tcandy.sprite.y = startY\n\n\t\t\t\t\tanimations.push(this.animateFill(candy, fallIndex))\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tawait Promise.all(animations)\n\t}\n\n\tprivate async animateFill(candy: CandyData, delay: number): Promise<void> {\n\t\treturn new Promise(resolve => {\n\t\t\tif (!candy.sprite) {\n\t\t\t\tresolve()\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst targetY = candy.row * (GRID.cellSize + GRID.gap) + GRID.cellSize / 2\n\n\t\t\tthis.tweens.add({\n\t\t\t\ttargets: candy.sprite,\n\t\t\t\ty: targetY,\n\t\t\t\tduration: ANIMATION.dropDurationPerRow * (candy.row + delay + 1),\n\t\t\t\tease: 'Bounce.easeOut',\n\t\t\t\tdelay: delay * 50,\n\t\t\t\tonComplete: () => resolve(),\n\t\t\t})\n\t\t})\n\t}\n\n\t// ==================== GAME STATE ====================\n\n\tprivate decrementMoves() {\n\t\tthis.gameState.moves--\n\t\tthis.updateMovesDisplay()\n\t\tthis.onMovesUpdate(this.gameState.moves)\n\t}\n\n\tprivate addScore(points: number) {\n\t\tthis.gameState.score += points\n\t\tthis.scoreText.setText(this.gameState.score.toString())\n\t\tthis.updateProgressBar()\n\t\tthis.onScoreUpdate(this.gameState.score)\n\n\t\t// Show score popup\n\t\tthis.showScorePopup(points)\n\t}\n\n\tprivate showScorePopup(points: number) {\n\t\t// Play score popup sound\n\t\tthis.audio?.playScorePopup()\n\n\t\tconst popup = this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2, `+${points}`, {\n\t\t\tfontFamily: '\"Luckiest Guy\", Arial, sans-serif',\n\t\t\tfontSize: '36px',\n\t\t\tcolor: '#ffd700',\n\t\t\tstroke: '#000000',\n\t\t\tstrokeThickness: 4,\n\t\t})\n\t\tpopup.setOrigin(0.5, 0.5)\n\t\tpopup.setDepth(100)\n\t\tpopup.setResolution(Math.min(window.devicePixelRatio || 1, 2))\n\n\t\tthis.tweens.add({\n\t\t\ttargets: popup,\n\t\t\ty: popup.y - 50,\n\t\t\talpha: 0,\n\t\t\tscale: 1.5,\n\t\t\tduration: ANIMATION.scorePopupDuration,\n\t\t\tease: 'Quad.easeOut',\n\t\t\tonComplete: () => popup.destroy(),\n\t\t})\n\t}\n\n\tprivate showChainIndicator(chainLevel: number) {\n\t\t// Play combo sound\n\t\tthis.audio?.playCombo(chainLevel)\n\n\t\tthis.chainIndicator.setText(`Combo x${chainLevel}!`)\n\t\tthis.chainIndicator.setAlpha(1)\n\n\t\tthis.tweens.add({\n\t\t\ttargets: this.chainIndicator,\n\t\t\talpha: 0,\n\t\t\tduration: ANIMATION.chainIndicatorDuration,\n\t\t\tease: 'Quad.easeIn',\n\t\t})\n\t}\n\n\tprivate checkGameEnd() {\n\t\tif (this.gameState.score >= this.gameState.targetScore) {\n\t\t\t// Win! Add bonus points for remaining moves\n\t\t\tconst movesBonus = this.gameState.moves * SCORING.movesBonus\n\t\t\tif (movesBonus > 0) {\n\t\t\t\tthis.addScore(movesBonus)\n\t\t\t\tthis.showMovesBonus(movesBonus)\n\t\t\t}\n\t\t\tthis.gameState.phase = 'result'\n\t\t\tthis.onPhaseChange('result')\n\t\t\tthis.audio?.playWin()\n\t\t\tthis.onGameComplete(true, this.gameState.score)\n\t\t} else if (this.gameState.moves <= 0) {\n\t\t\t// Out of moves - fail\n\t\t\tthis.gameState.phase = 'result'\n\t\t\tthis.onPhaseChange('result')\n\t\t\tthis.audio?.playLose()\n\t\t\tthis.onGameComplete(false, this.gameState.score)\n\t\t}\n\t}\n\n\tprivate showMovesBonus(bonus: number) {\n\t\tconst bonusText = this.add.text(\n\t\t\tGAME_WIDTH / 2,\n\t\t\tGAME_HEIGHT / 2 - 40,\n\t\t\t`Bonus por turnos!\\n+${bonus}`,\n\t\t\t{\n\t\t\t\tfontFamily: '\"Luckiest Guy\", Arial, sans-serif',\n\t\t\t\tfontSize: '28px',\n\t\t\t\tcolor: '#4caf50',\n\t\t\t\talign: 'center',\n\t\t\t\tstroke: '#000000',\n\t\t\t\tstrokeThickness: 4,\n\t\t\t}\n\t\t)\n\t\tbonusText.setOrigin(0.5, 0.5)\n\t\tbonusText.setDepth(100)\n\t\tbonusText.setResolution(Math.min(window.devicePixelRatio || 1, 2))\n\n\t\tthis.tweens.add({\n\t\t\ttargets: bonusText,\n\t\t\ty: bonusText.y - 60,\n\t\t\talpha: 0,\n\t\t\tscale: 1.3,\n\t\t\tduration: 1500,\n\t\t\tease: 'Quad.easeOut',\n\t\t\tonComplete: () => bonusText.destroy(),\n\t\t})\n\t}\n\n\t// ==================== SHUFFLE MECHANISM ====================\n\n\tprivate hasValidMoves(): boolean {\n\t\t// Check if any swap would create a match\n\t\tfor (let row = 0; row < GRID.size; row++) {\n\t\t\tfor (let col = 0; col < GRID.size; col++) {\n\t\t\t\t// Check swap right\n\t\t\t\tif (\n\t\t\t\t\tcol < GRID.size - 1 &&\n\t\t\t\t\tthis.wouldCreateMatch(row, col, row, col + 1)\n\t\t\t\t) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\t// Check swap down\n\t\t\t\tif (\n\t\t\t\t\trow < GRID.size - 1 &&\n\t\t\t\t\tthis.wouldCreateMatch(row, col, row + 1, col)\n\t\t\t\t) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false\n\t}\n\n\tprivate wouldCreateMatch(\n\t\trow1: number,\n\t\tcol1: number,\n\t\trow2: number,\n\t\tcol2: number\n\t): boolean {\n\t\tconst candy1 = this.grid[row1][col1]\n\t\tconst candy2 = this.grid[row2][col2]\n\t\tif (!candy1 || !candy2) return false\n\n\t\t// Temporarily swap\n\t\tthis.grid[row1][col1] = candy2\n\t\tthis.grid[row2][col2] = candy1\n\t\tconst tempRow = candy1.row\n\t\tconst tempCol = candy1.col\n\t\tcandy1.row = row2\n\t\tcandy1.col = col2\n\t\tcandy2.row = row1\n\t\tcandy2.col = col1\n\n\t\tlet hasMatch = false\n\n\t\t// Check for matches at both positions\n\t\t// Handle bombs specially - they can join any match\n\t\tif (candy2.isBomb) {\n\t\t\thasMatch =\n\t\t\t\thasMatch ||\n\t\t\t\tthis.findBombHorizontalMatch(row1, col1).length >= 3 ||\n\t\t\t\tthis.findBombVerticalMatch(row1, col1).length >= 3\n\t\t} else {\n\t\t\thasMatch =\n\t\t\t\thasMatch ||\n\t\t\t\tthis.findHorizontalMatch(row1, col1, candy2.type).length >= 3 ||\n\t\t\t\tthis.findVerticalMatch(row1, col1, candy2.type).length >= 3\n\t\t}\n\n\t\tif (candy1.isBomb) {\n\t\t\thasMatch =\n\t\t\t\thasMatch ||\n\t\t\t\tthis.findBombHorizontalMatch(row2, col2).length >= 3 ||\n\t\t\t\tthis.findBombVerticalMatch(row2, col2).length >= 3\n\t\t} else {\n\t\t\thasMatch =\n\t\t\t\thasMatch ||\n\t\t\t\tthis.findHorizontalMatch(row2, col2, candy1.type).length >= 3 ||\n\t\t\t\tthis.findVerticalMatch(row2, col2, candy1.type).length >= 3\n\t\t}\n\n\t\t// Swap back\n\t\tthis.grid[row1][col1] = candy1\n\t\tthis.grid[row2][col2] = candy2\n\t\tcandy1.row = tempRow\n\t\tcandy1.col = tempCol\n\t\tcandy2.row = row2\n\t\tcandy2.col = col2\n\n\t\treturn hasMatch\n\t}\n\n\tprivate async shuffleBoard(): Promise<void> {\n\t\t// Show shuffle message\n\t\tconst shuffleText = this.add.text(\n\t\t\tGAME_WIDTH / 2,\n\t\t\tGAME_HEIGHT / 2,\n\t\t\t'Sin movimientos\\nMezclando!',\n\t\t\t{\n\t\t\t\tfontFamily: '\"Luckiest Guy\", Arial, sans-serif',\n\t\t\t\tfontSize: '28px',\n\t\t\t\tcolor: '#ffffff',\n\t\t\t\talign: 'center',\n\t\t\t\tstroke: '#000000',\n\t\t\t\tstrokeThickness: 4,\n\t\t\t}\n\t\t)\n\t\tshuffleText.setOrigin(0.5, 0.5)\n\t\tshuffleText.setDepth(100)\n\t\tshuffleText.setResolution(Math.min(window.devicePixelRatio || 1, 2))\n\n\t\t// Fade in\n\t\tshuffleText.setAlpha(0)\n\t\tawait new Promise<void>(resolve => {\n\t\t\tthis.tweens.add({\n\t\t\t\ttargets: shuffleText,\n\t\t\t\talpha: 1,\n\t\t\t\tduration: 300,\n\t\t\t\tonComplete: () => resolve(),\n\t\t\t})\n\t\t})\n\n\t\t// Collect candy types and bombs (bombs stay in place)\n\t\tconst candyTypes: number[] = []\n\t\tconst bombs: { row: number; col: number; bombType: BombType }[] = []\n\n\t\tfor (let row = 0; row < GRID.size; row++) {\n\t\t\tfor (let col = 0; col < GRID.size; col++) {\n\t\t\t\tconst candy = this.grid[row][col]\n\t\t\t\tif (candy) {\n\t\t\t\t\tif (candy.isBomb && candy.bombType) {\n\t\t\t\t\t\tbombs.push({ row, col, bombType: candy.bombType })\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcandyTypes.push(candy.type)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Fisher-Yates shuffle for regular candies only\n\t\tfor (let i = candyTypes.length - 1; i > 0; i--) {\n\t\t\tconst j = Phaser.Math.Between(0, i)\n\t\t\t;[candyTypes[i], candyTypes[j]] = [candyTypes[j], candyTypes[i]]\n\t\t}\n\n\t\t// Destroy all existing candies\n\t\tfor (let row = 0; row < GRID.size; row++) {\n\t\t\tfor (let col = 0; col < GRID.size; col++) {\n\t\t\t\tconst candy = this.grid[row][col]\n\t\t\t\tif (candy) {\n\t\t\t\t\tthis.destroyCandy(candy)\n\t\t\t\t\tthis.grid[row][col] = null\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create a set of bomb positions for quick lookup\n\t\tconst bombPositions = new Set(bombs.map(b => `${b.row},${b.col}`))\n\n\t\t// Redistribute candies and bombs\n\t\tlet dataIndex = 0\n\t\tfor (let row = 0; row < GRID.size; row++) {\n\t\t\tfor (let col = 0; col < GRID.size; col++) {\n\t\t\t\tconst key = `${row},${col}`\n\t\t\t\tif (bombPositions.has(key)) {\n\t\t\t\t\t// Restore bomb at its original position\n\t\t\t\t\tconst bomb = bombs.find(b => b.row === row && b.col === col)!\n\t\t\t\t\tconst candy = this.createCandy(row, col, undefined, bomb.bombType)\n\t\t\t\t\tthis.grid[row][col] = candy\n\t\t\t\t} else {\n\t\t\t\t\tconst candyType = candyTypes[dataIndex++]\n\t\t\t\t\tconst candy = this.createCandy(row, col, candyType)\n\t\t\t\t\tthis.grid[row][col] = candy\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove any matches created by shuffle\n\t\tthis.removeInitialMatches()\n\n\t\t// Short delay for visual effect\n\t\tawait new Promise<void>(resolve => {\n\t\t\tthis.time.delayedCall(500, resolve)\n\t\t})\n\n\t\t// Fade out shuffle text\n\t\tawait new Promise<void>(resolve => {\n\t\t\tthis.tweens.add({\n\t\t\t\ttargets: shuffleText,\n\t\t\t\talpha: 0,\n\t\t\t\tduration: 300,\n\t\t\t\tonComplete: () => {\n\t\t\t\t\tshuffleText.destroy()\n\t\t\t\t\tresolve()\n\t\t\t\t},\n\t\t\t})\n\t\t})\n\t}\n\n\tprivate async checkAndShuffleIfNeeded(): Promise<void> {\n\t\t// Keep shuffling until we have valid moves (max 10 attempts to prevent infinite loop)\n\t\tlet attempts = 0\n\t\twhile (!this.hasValidMoves() && attempts < 10) {\n\t\t\tawait this.shuffleBoard()\n\t\t\tattempts++\n\t\t}\n\t}\n}\n","'use client'\n\nimport React, { useEffect, useRef, useCallback } from 'react'\nimport Phaser from 'phaser'\nimport { BootScene } from './scenes/BootScene'\nimport { MainScene } from './scenes/MainScene'\nimport { GAME_WIDTH, GAME_HEIGHT, COLORS } from './constants'\nimport { GamePhase, LevelConfig } from './types'\nimport { candyCrushAudio } from './utils/audioManager'\n\ninterface CandyCrushCoreProps {\n\tonScoreUpdate: (score: number) => void\n\tonMovesUpdate: (moves: number) => void\n\tonGameComplete: (won: boolean, score: number) => void\n\tonPhaseChange?: (phase: GamePhase) => void\n\tbrandColor?: string\n\tskin?: string\n\tlives?: number\n\tlevelConfig: LevelConfig\n}\n\nconst CandyCrushCore: React.FC<CandyCrushCoreProps> = ({\n\tonScoreUpdate,\n\tonMovesUpdate,\n\tonGameComplete,\n\tonPhaseChange,\n\tbrandColor,\n\tskin,\n\tlives = 3,\n\tlevelConfig,\n}) => {\n\tconst gameContainerRef = useRef<HTMLDivElement>(null)\n\tconst gameRef = useRef<Phaser.Game | null>(null)\n\n\t// Memoize callbacks to prevent unnecessary re-renders\n\tconst handleScoreUpdate = useCallback(\n\t\t(score: number) => {\n\t\t\tonScoreUpdate(score)\n\t\t},\n\t\t[onScoreUpdate]\n\t)\n\n\tconst handleMovesUpdate = useCallback(\n\t\t(moves: number) => {\n\t\t\tonMovesUpdate(moves)\n\t\t},\n\t\t[onMovesUpdate]\n\t)\n\n\tconst handleGameComplete = useCallback(\n\t\t(won: boolean, score: number) => {\n\t\t\tonGameComplete(won, score)\n\t\t},\n\t\t[onGameComplete]\n\t)\n\n\tconst handlePhaseChange = useCallback(\n\t\t(phase: GamePhase) => {\n\t\t\tif (onPhaseChange) {\n\t\t\t\tonPhaseChange(phase)\n\t\t\t}\n\t\t},\n\t\t[onPhaseChange]\n\t)\n\n\t// Initialize Phaser game\n\tuseEffect(() => {\n\t\tif (!gameContainerRef.current || gameRef.current) return\n\n\t\t// Use higher base resolution for crisp text on all displays\n\t\tconst config: Phaser.Types.Core.GameConfig = {\n\t\t\ttype: Phaser.WEBGL,\n\t\t\tparent: gameContainerRef.current,\n\t\t\twidth: GAME_WIDTH,\n\t\t\theight: GAME_HEIGHT,\n\t\t\tbackgroundColor: COLORS.background,\n\t\t\tscene: [BootScene, MainScene],\n\t\t\tscale: {\n\t\t\t\tmode: Phaser.Scale.FIT,\n\t\t\t\tautoCenter: Phaser.Scale.CENTER_BOTH,\n\t\t\t},\n\t\t\trender: {\n\t\t\t\tpixelArt: false,\n\t\t\t\tantialias: true,\n\t\t\t\tantialiasGL: true,\n\t\t\t\tbatchSize: 4096,\n\t\t\t},\n\t\t\tinput: {\n\t\t\t\tactivePointers: 1,\n\t\t\t},\n\t\t}\n\n\t\tgameRef.current = new Phaser.Game(config)\n\n\t\t// Pass callbacks to Phaser via registry\n\t\tgameRef.current.registry.set('onScoreUpdate', handleScoreUpdate)\n\t\tgameRef.current.registry.set('onMovesUpdate', handleMovesUpdate)\n\t\tgameRef.current.registry.set('onGameComplete', handleGameComplete)\n\t\tgameRef.current.registry.set('onPhaseChange', handlePhaseChange)\n\t\tgameRef.current.registry.set('brandColor', brandColor)\n\t\tgameRef.current.registry.set('skin', skin)\n\t\tgameRef.current.registry.set('lives', lives)\n\t\tgameRef.current.registry.set('levelConfig', levelConfig)\n\t\tgameRef.current.registry.set('audioManager', candyCrushAudio)\n\n\t\t// Cleanup on unmount\n\t\treturn () => {\n\t\t\tif (gameRef.current) {\n\t\t\t\tgameRef.current.destroy(true)\n\t\t\t\tgameRef.current = null\n\t\t\t}\n\t\t}\n\t}, [\n\t\thandleScoreUpdate,\n\t\thandleMovesUpdate,\n\t\thandleGameComplete,\n\t\thandlePhaseChange,\n\t\tbrandColor,\n\t\tskin,\n\t\tlives,\n\t\tlevelConfig,\n\t])\n\n\treturn (\n\t\t<div\n\t\t\tref={gameContainerRef}\n\t\t\tclassName=\"w-full h-full flex items-center justify-center\"\n\t\t\tstyle={{\n\t\t\t\ttouchAction: 'none',\n\t\t\t\tuserSelect: 'none',\n\t\t\t}}\n\t\t/>\n\t)\n}\n\nexport default CandyCrushCore\n"],"names":["BootScene","Phaser","constructor","super","key","preload","progressBar","this","add","graphics","progressBox","fillStyle","fillRect","GAME_WIDTH","GAME_HEIGHT","loadingText","text","fontFamily","fontSize","color","setOrigin","setResolution","Math","min","window","devicePixelRatio","load","on","value","clear","CANDY_COLORS","destroy","skin","registry","get","basePath","skinPath","concat","spritesheet","frameWidth","frameHeight","create","candiesLoaded","textures","exists","set","generateProceduralCandies","generateParticleTexture","scene","start","make","x","y","i","length","fillCircle","generateTexture","MainScene","grid","gridContainer","levelConfig","candyTypes","gameState","selectedCandy","isAnimating","useProcedural","scoreText","movesText","targetText","chainIndicator","onScoreUpdate","onMovesUpdate","onGameComplete","onPhaseChange","selectionIndicator","audio","LEVELS","phase","score","moves","targetScore","livesRemaining","chainLevel","lastMatchPoints","createBackground","createUI","createGrid","fillGridWithCandies","removeInitialMatches","setupInput","bg","COLORS","background","gridBg","gridBackground","fillRoundedRect","GRID","offsetX","offsetY","GRID_PIXEL_SIZE","lineStyle","gridBorder","strokeRoundedRect","gameFont","textResolution","createHeaderPanel","UI","targetDisplay","align","updateTargetDisplay","scoreDisplay","movesDisplay","updateMovesDisplay","updateProgressBar","gridBottom","stroke","strokeThickness","setAlpha","setDepth","panel","headerPanel","header","width","height","borderRadius","tl","tr","bl","br","headerBorder","cardY","padding","cardHeight","statCard","createStatCard","targetAccent","scoreCardWidth","scoreAccent","movesAccent","accentColor","label","accentHeight","statCardBg","labelText","setText","barRadius","progress","fillWidth","max","fillColor","container","row","size","col","candy","createCandy","type","bombType","bombConfig","candyType","isBomb","actualBombType","undefined","random","spawnChance","Between","cellSize","gap","sprite","frame","BOMB_FRAMES","setDisplaySize","CANDY_SPRITE","displaySize","setInteractive","iterations","matches","findAllMatches","match","cell","cells","newType","findNonMatchingType","setTexture","setFrame","invalidTypes","Set","left1","left2","up1","up2","validTypes","t","has","push","dragStartCandy","input","pointer","getCellFromPointer","clearSelection","selectCandy","isDown","targetCandy","isAdjacent","trySwap","floor","candy1","candy2","dr","abs","dc","_this$audio","playSelect","tweens","targets","scale","baseScale","ANIMATION","selectScale","duration","selectDuration","ease","_this$selectedCandy","animateSwap","swapInGrid","findMatchesAtPositions","_this$audio2","decrementMoves","processMatches","checkGameEnd","playInvalidMove","tempRow","tempCol","_this$audio3","playSwap","Promise","resolve","x1","y1","x2","y2","completed","checkComplete","swapDuration","onComplete","matchStart","matchLength","current","previous","c","r","mergeIntersectingMatches","positions","allMatches","pos","hMatch","findBombHorizontalMatch","map","vMatch","findBombVerticalMatch","findHorizontalMatch","findVerticalMatch","targetType","result","neighbor","unshift","_this$grid$row$c","_this$grid$row$c2","_this$grid$r$col","_this$grid$r$col2","usedIndices","match1","merged","j","match2","findIntersection","mergedCells","Map","Array","from","values","isT","cell1","cell2","matchesOverlap","getCrossBombCells","bomb","addedCells","getRadiusBombCells","showBombExplosion","_this$audio4","playBombExplode","explosion","setPosition","alpha","particleCount","angle","PI","distance","particle","cos","sin","calculateBombScore","cellsCleared","BOMB_SCORING","crossActivation","radiusActivation","perCandyCleared","_this$audio5","showChainIndicator","bombsInMatches","cellsToClear","processedBombs","bombQueue","totalBombScore","shift","bombKey","bombCells","clearedCandy","matchPoints","calculateMatchPoints","addScore","maxMatchLength","m","playMatchSound","cellsArray","clearMatch","bombReward","checkForBombReward","animateMatches","removeMatches","dropCandies","fillEmptyCells","checkAndShuffleIfNeeded","matchSpawnChance","centerIndex","points","SCORING","match3","match4","match5","matchLT","chainBonus","animations","processedCells","animateClearCandy","all","createMatchParticles","clearDuration","useSprites","setTint","setScale","destroyCandy","emptyRow","dropDistance","animateDrop","targetY","dropDurationPerRow","emptyCells","fallIndex","startY","animateFill","delay","toString","showScorePopup","_this$audio6","playScorePopup","popup","scorePopupDuration","_this$audio7","playCombo","chainIndicatorDuration","_this$audio8","movesBonus","showMovesBonus","playWin","_this$audio9","playLose","bonus","bonusText","hasValidMoves","wouldCreateMatch","row1","col1","row2","col2","hasMatch","shuffleBoard","shuffleText","bombs","bombPositions","b","dataIndex","find","time","delayedCall","attempts","_ref","brandColor","lives","gameContainerRef","useRef","gameRef","handleScoreUpdate","useCallback","handleMovesUpdate","handleGameComplete","won","handlePhaseChange","useEffect","config","parent","backgroundColor","mode","FIT","autoCenter","CENTER_BOTH","render","pixelArt","antialias","antialiasGL","batchSize","activePointers","candyCrushAudio","_jsx","ref","className","style","touchAction","userSelect"],"sourceRoot":""}